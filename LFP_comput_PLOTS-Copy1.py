#!/usr/bin/env python
# coding: utf-8

# In[ ]:


#This program compute the LFP based on the data files generated by the main program


# In[1]:


import numpy as np
import time
import matplotlib.pyplot as plt


# In[2]:


#Importing some info I need for this program
runtime=np.loadtxt("general_files/runtime.txt")*1000 #because I want ms
#print(runtime)
dt_sim=np.loadtxt("general_files/dt_sim.txt")

Iext=np.loadtxt('Iext.txt')
#print(Iext[1][0])


# In[3]:


#Import all the currents I need for LFP computation
igabaE23=np.load("LFP_files/igabaE23.npy")
iampaE23=np.load("LFP_files/iampaE23.npy")
inmdaE23=np.load("LFP_files/inmdaE23.npy")
iampaextE23=np.load("LFP_files/iampaextE23.npy")

igabaE4=np.load("LFP_files/igabaE4.npy")
iampaE4=np.load("LFP_files/iampaE4.npy")
inmdaE4=np.load("LFP_files/inmdaE4.npy")
iampaextE4=np.load("LFP_files/iampaextE4.npy")

igabaE5=np.load("LFP_files/igabaE5.npy")
iampaE5=np.load("LFP_files/iampaE5.npy")
inmdaE5=np.load("LFP_files/inmdaE5.npy")
iampaextE5=np.load("LFP_files/iampaextE5.npy")

igabaE6=np.load("LFP_files/igabaE6.npy")
iampaE6=np.load("LFP_files/iampaE6.npy")
inmdaE6=np.load("LFP_files/inmdaE6.npy")
iampaextE6=np.load("LFP_files/iampaextE6.npy")
#print(iampaextE23I_AMPA_ext)


# In[4]:


#parameters for LFP computation
#dt_sim=0.1 runtime=3000
steps=(runtime)/dt_sim
print(steps)
print(steps-60)
tau=60
alpha=1.65


# In[5]:


#number of neurons from which I recorded
num=np.array(np.loadtxt('LFP_files/numberLFP.txt') )
#Import the weights I computed 
W23=np.array(np.loadtxt('LFP_files/weight23.txt') )
W4=np.array(np.loadtxt('LFP_files/weight4.txt') )
W5=np.array(np.loadtxt('LFP_files/weight5.txt') )
W6=np.array(np.loadtxt('LFP_files/weight6.txt') )


# In[6]:


#Function to compute the LFP contribution from each layer
def LFP_contribution(igabaE,iampaE,inmdaE,iampaextE,weight,Num_neu,steps,tau,alpha):
    Num_neu=int(Num_neu)
    gaba_all=[0 for i in range(0,int(steps-tau))]
    ampa_all=[0 for i in range(0,int(steps-tau))]
    nmda_all=[0 for i in range(0,int(steps-tau))]
    ampaext_all=[0 for i in range(0,int(steps-tau))]
    for i in range(0,Num_neu):
        #print(weight[i])
        gaba_all+=weight[i]*np.array(-igabaE[i][:-tau])
        #print(gaba_all[200:300])
        ampa_all+=weight[i]*np.array(-iampaE[i][tau:])
        nmda_all+=weight[i]*np.array(-inmdaE[i][:-tau])
        ampaext_all+=weight[i]*np.array(-iampaextE[i][:-tau])
    print(gaba_all[:100])
    #print(len(ampa_all))    
    LFP_array= ampaext_all + ampa_all - alpha*gaba_all + nmda_all #SUM OF I (ABS)
    
    return LFP_array


# In[7]:


#Function to compute the LFP contribution from each layer if I have an input to that layer. I need to take into account the extra current going to the neurons in the LFP computation
def LFP_contribution_I(igabaE,iampaE,inmdaE,iampaextE,weight,Iext,Num_neu,steps,tau,alpha):
    Num_neu=int(Num_neu)
    #when input is constant use this
    inputE_ext=[Iext for i in range(0,int(steps))] #This is the same for all neurons, I only need one of them
    inputE_ext=np.array(inputE_ext)

#     #when input changes use this
#     t1=500*10
#     t2=800*10
#     t3=2100*10
#     t4=2300*10
#     runtime=3000*10
#     y = np.array([0 for i in range(0,t1)])
#     y1=np.array([Iext for i in range(t1,t2)])
#     y2=np.array([0 for i in range(t2,t3)])
#     y3=np.array([Iext for i in range(t3,t4)])
#     y4=np.array([0 for i in range(t4,runtime)])
#     I=np.concatenate((y, y1,y2,y3,y4), axis=0)
#     inputE_ext=np.array(I)
    
    #print(inputE_ext)
    gaba_all=[0 for i in range(0,int(steps-tau))]
    ampa_all=[0 for i in range(0,int(steps-tau))]
    nmda_all=[0 for i in range(0,int(steps-tau))]
    ampaext_all=[0 for i in range(0,int(steps-tau))]
    I_ext_all=[0 for i in range(0,int(steps-tau)) ]
    for i in range(0,Num_neu):
        gaba_all+=weight[i]*np.array(-igabaE[i][:-tau])
        ampa_all+=weight[i]*np.array(-iampaE[i][tau:])
        nmda_all+=weight[i]*np.array(-inmdaE[i][:-tau])
        ampaext_all+=weight[i]*np.array(-iampaextE[i][:-tau])
        I_ext_all+=weight[i]*np.array(-inputE_ext[:-tau])
    #print(I_ext_all)    
    #LFP_array=ampa_all - alpha*gaba_all #it'a an array
    LFP_array= ampaext_all + ampa_all - alpha*gaba_all + nmda_all + I_ext_all#SUM OF I (ABS)
    
    return LFP_array


# In[33]:


#I normalize the LFP signal
def LFP_final(LFP_summed):
    
    import statistics
    std_LFP=statistics.stdev(LFP_summed)
    print(std_LFP)
    LFP_array_norm= (LFP_summed-np.mean(LFP_summed))/std_LFP

#     #Check that is 1
#     std_LFPnorm=statistics.stdev(LFP_array_norm)
#     print(std_LFPnorm)

    return LFP_array_norm


# In[9]:


#Call the function computing the contributions
LFP_e4= LFP_contribution(igabaE4,iampaE4,inmdaE4,iampaextE4,W4,num[1],steps,tau,alpha)
LFP_e23= LFP_contribution(igabaE23,iampaE23,inmdaE23,iampaextE23,W23,num[0],steps,tau,alpha)


# In[10]:


#LFP_e4= LFP_contribution_I(igabaE4,iampaE4,inmdaE4,iampaextE4,W4,Iext[1][0],num[1],steps,tau,alpha)
# LFP_e4= LFP_contribution(igabaE4,iampaE4,inmdaE4,iampaextE4,W4,num[1],steps,tau,alpha)
# LFP_e5= LFP_contribution(igabaE5,iampaE5,inmdaE5,iampaextE5,W5,num[2],steps,tau,alpha)
# LFP_e6= LFP_contribution(igabaE6,iampaE6,inmdaE6,iampaextE6,W6,num[3],steps,tau,alpha)


# In[39]:


#SUm the contributions
LFP_all=LFP_e4+LFP_e23


# In[40]:


#print(LFP_all[0:100])


# In[56]:


#Normalize the LFP signal
LFP_norm= LFP_final(LFP_all)
# print(LFP_norm[10000:12000])
# print(len(LFP_norm))


# In[57]:


#FROM the file of electrode data I have these values, from where I have recorded
el_data=np.array(np.loadtxt('LFP_files/electrode_data.txt') )
rad_action= el_data[0]
depth=el_data[1]  
radius=el_data[2]  
alpha=el_data[3]    

print(rad_action)
print(depth)
print(radius)
print(alpha)


# In[58]:


#Function to plot the LFP signal
def plot_LFP(LFP,steps,tau,depth,radius,alpha,rad_action,xmin,xmax,ymin,ymax):
    fig3 = plt.figure(figsize=(15,7))
    times=[i/10 for i in range(0,int(steps-tau))]
    #print(times)
    plt.plot(times,LFP,color='blue',label='LFP')  #I divide it by 10^-9 to have adimentional measure. 
    plt.xlabel('time (ms)')
    plt.ylabel('LFP (mV)')
    plt.title('LFP with electrode at d=%i, r=%i, alpha=%i, rad_action=%i'%(depth,radius,alpha,rad_action))
    plt.xlim(xmin,xmax)
    plt.ylim(ymin,ymax)
    plt.legend()
    plt.show()


# In[59]:


plot_LFP(LFP_norm,steps,tau,depth,radius,alpha,rad_action,1000,1200,-6,6)


# In[60]:


#Function to compute the power spectrum
def power_spectrum(LFP,sec):
    data = LFP
    print(len(data))
    #le ampiezze non sono relative alle freq in hertz ma al numero di oscillazionin complete nel mio intervallo
    #il primo numero dell'array e' l'ampiezza della frequenza che ci sta una volta (onda che fa 1 giro nell'intervallo), 
    #il secondo numero e' l'ampiezza della frequenza che ci sta due volte (l'onda fa il giro completo 2 volte)
    fourier_transform = np.fft.rfft(data)
    abs_fourier_transform = np.abs(fourier_transform)
    power_spectrum = np.square(abs_fourier_transform)
    #print(fourier_transform[0:100])
    #print(len(fourier_transform)) #Circa meta' della lunghezza della mia time series da analizzare
    #print(power_spectrum)
    # x divided by the time in s of my simulation to obtain Hz (sec is given to the function)
    frequency=[x/sec for x in range(0,len(power_spectrum))]

    return frequency, power_spectrum

def plot_power_spectrum(frequency, power_spectrum,depth,radius,alpha,rad_action):
    fig3 = plt.figure(figsize=(15,7))
    plt.plot(frequency[1:], power_spectrum[1:])
    #plt.yscale('log')
    plt.xscale('log')
    plt.xlabel('frequency (Hz)')
    plt.ylabel('power spectrum LFP (mv)')
    plt.title('LFP power spectrum with electrode at d=%s, r=%s, alpha=%s, rad_action=%s'%(depth,radius,alpha,rad_action))
    plt.xlim(1,100)


# In[62]:


#I call the function to compute the power spectrum of LFP and then I plot it
frequency_LFP,power_spectrum_LFP=power_spectrum(LFP_norm,runtime/1000) #I need sec of simulation, runtime is in ms
plot_power_spectrum(frequency_LFP, power_spectrum_LFP,depth,radius,alpha,rad_action)


# In[18]:


#function to plot the currents that one neuron is reciving
def plot_current(steps,iampaE,inmdaE,igabaE,iampaextE,neuron_index):
    fig2 = plt.figure(figsize=(15,7))
    time=[i for i in range(0,int(steps))]
    plt.plot(time,-iampaE[neuron_index],label='e ampa')  #I divide it by 10^-9 to have adimentional measure. 
    plt.plot(time,-inmdaE[neuron_index],label='e nmda')  #I divide it by 10^-9 to have adimentional measure. 
    plt.plot(time,-igabaE[neuron_index],label='e gaba')
    plt.plot(time,-iampaextE[neuron_index],label='e ext')
    plt.xlabel('time (ms)')
    plt.ylabel('Psc current (pA)')
    plt.title('Psc current AMPA NMDA GABA ampaext for neuron %s'%(neuron_index))
    plt.legend()
    plt.show()


# In[19]:


#plot the currents of 1 neuron
plot_current(steps,iampaE4,inmdaE4,igabaE4,iampaextE4,10)

